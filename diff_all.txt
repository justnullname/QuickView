diff --git a/QuickView/EditState.h b/QuickView/EditState.h
index 99601f5..448f6b3 100644
--- a/QuickView/EditState.h
+++ b/QuickView/EditState.h
@@ -103,6 +103,11 @@ struct AppConfig {
     // --- Image & Edit ---
     bool AutoRotate = true;
     bool ColorManagement = false;
+    
+    // --- Save Options ---
+    bool EnableLosslessTransform = true;// Enable JPEG lossless rot UI/Logic
+    bool EnableLossyTransform = true;   // Enable Re-encoding UI/Logic
+    bool EnableEdgeClip = false;        // Clip edges when saving JPEG lossless if dimensions mismatch MCU
 
     // Existing / Internal (Defaults for Runtime)
     bool AutoSaveOnSwitch = false;       
diff --git a/QuickView/ImageLoader.cpp b/QuickView/ImageLoader.cpp
index 35152ef..a174062 100644
--- a/QuickView/ImageLoader.cpp
+++ b/QuickView/ImageLoader.cpp
@@ -14,6 +14,8 @@
 #include "WuffsLoader.h"
 #include "StbLoader.h"
 #include "TinyExrLoader.h"
+#include <immintrin.h> // SIMD
+#include "SIMDUtils.h"
 #include <thread>
 #include "PreviewExtractor.h"
 
@@ -45,9 +47,12 @@ static std::wstring DetectFormatFromContent(LPCWSTR filePath) {
     if (magic[0] == 'R' && magic[1] == 'I' && magic[2] == 'F' && magic[3] == 'F' &&
              magic[8] == 'W' && magic[9] == 'E' && magic[10] == 'B' && magic[11] == 'P') return L"WebP";
         
-    // Check AVIF: ftypavif
-    if (magic[4] == 'f' && magic[5] == 't' && magic[6] == 'y' && magic[7] == 'p' &&
-             magic[8] == 'a' && magic[9] == 'v' && magic[10] == 'i' && magic[11] == 'f') return L"AVIF";
+    // Check AVIF: ftypavif OR ftypavis (AVIF Sequence)
+    if (magic[4] == 'f' && magic[5] == 't' && magic[6] == 'y' && magic[7] == 'p') {
+        bool isAvif = (magic[8] == 'a' && magic[9] == 'v' && magic[10] == 'i' && magic[11] == 'f');
+        bool isAvis = (magic[8] == 'a' && magic[9] == 'v' && magic[10] == 'i' && magic[11] == 's');
+        if (isAvif || isAvis) return L"AVIF";
+    }
 
     // Check HEIC/HEIF: ftyp + brand
     // Common brands: heic, heix, hevc, heim, heis, hevm, hevs, mif1, msf1
@@ -686,6 +691,9 @@ HRESULT CImageLoader::LoadWebP(LPCWSTR filePath, IWICBitmap** ppBitmap) {
     int stride = config.output.u.RGBA.stride;
     int size = stride * height;
 
+    // Manual Premultiplication (SIMD)
+    SIMDUtils::PremultiplyAlpha_BGRA(output, width, height);
+
     HRESULT hr = CreateWICBitmapFromMemory(width, height, GUID_WICPixelFormat32bppPBGRA, stride, size, output, ppBitmap);
     
     // Extract format details (VP8 = Lossy, VP8L/Lossless Flag = Lossless)
@@ -727,6 +735,9 @@ HRESULT CImageLoader::LoadAVIF(LPCWSTR filePath, IWICBitmap** ppBitmap) {
         decoder->maxThreads = 4; // Fallback sensible default
     }
     
+    // Disable strict flags to improve compatibility with non-compliant or experimental files
+    decoder->strictFlags = AVIF_STRICT_DISABLED;
+    
     // Set Memory Source
     if (avifDecoderSetIOMemory(decoder, avifBuf.data(), avifBuf.size()) != AVIF_RESULT_OK) {
         avifDecoderDestroy(decoder);
@@ -752,6 +763,7 @@ HRESULT CImageLoader::LoadAVIF(LPCWSTR filePath, IWICBitmap** ppBitmap) {
     // Configure for WIC (BGRA, 8-bit)
     rgb.format = AVIF_RGB_FORMAT_BGRA;
     rgb.depth = 8;
+    rgb.alphaPremultiplied = AVIF_TRUE; // Re-enabled native premul as per user request
     
     // Calculate stride and size
     rgb.rowBytes = rgb.width * 4;
@@ -988,7 +1000,8 @@ HRESULT CImageLoader::LoadToMemory(LPCWSTR filePath, IWICBitmap** ppBitmap, std:
         HRESULT hr = LoadWebP(filePath, ppBitmap);
         if (SUCCEEDED(hr)) { if (pLoaderName) *pLoaderName = L"libwebp"; return S_OK; }
     }
-    else if (detectedFmt == L"AVIF") {
+    else if (detectedFmt == L"AVIF" || 
+             ((detectedFmt == L"HEIC" || detectedFmt == L"Unknown") && (path.ends_with(L".avif") || path.ends_with(L".avifs")))) {
         HRESULT hr = LoadAVIF(filePath, ppBitmap);
         if (SUCCEEDED(hr)) { if (pLoaderName) *pLoaderName = L"libavif"; return S_OK; }
     }
diff --git a/QuickView/SettingsOverlay.cpp b/QuickView/SettingsOverlay.cpp
index bbdecfc..429aa98 100644
--- a/QuickView/SettingsOverlay.cpp
+++ b/QuickView/SettingsOverlay.cpp
@@ -251,7 +251,7 @@ void SettingsOverlay::BuildMenu() {
     
     tabControl.items.push_back({ L"Edge", OptionType::Header });
     tabControl.items.push_back({ L"Edge Nav Click", OptionType::Toggle, &g_config.EdgeNavClick });
-    tabControl.items.push_back({ L"Nav Indicator", OptionType::Segment, nullptr, nullptr, BindEnum(&g_config.NavIndicator), nullptr, 0, 0, {L"Arrow", L"Glow"} });
+    tabControl.items.push_back({ L"Nav Indicator", OptionType::Segment, nullptr, nullptr, BindEnum(&g_config.NavIndicator), nullptr, 0, 0, {L"Arrow", L"Glow", L"None"} });
 
     m_tabs.push_back(tabControl);
 
@@ -269,6 +269,11 @@ void SettingsOverlay::BuildMenu() {
     tabImage.items.push_back(itemRaw);
     
     tabImage.items.push_back({ L"Save", OptionType::Header });
+    tabImage.items.push_back({ L"Allow Lossless Transform", OptionType::Toggle, &g_config.EnableLosslessTransform });
+    tabImage.items.push_back({ L"Allow Re-encoding", OptionType::Toggle, &g_config.EnableLossyTransform });
+    tabImage.items.push_back({ L"Allow Edge Clip (Lossless)", OptionType::Toggle, &g_config.EnableEdgeClip });
+    
+    tabImage.items.push_back({ L"Prompts", OptionType::Header });
     tabImage.items.push_back({ L"Auto Save (Lossless)", OptionType::Toggle, &g_config.AlwaysSaveLossless });
     tabImage.items.push_back({ L"Auto Save (Edge Adapted)", OptionType::Toggle, &g_config.AlwaysSaveEdgeAdapted });
     tabImage.items.push_back({ L"Auto Save (Lossy)", OptionType::Toggle, &g_config.AlwaysSaveLossy });
diff --git a/QuickView/main.cpp b/QuickView/main.cpp
index fc5f2b4..2f3881e 100644
--- a/QuickView/main.cpp
+++ b/QuickView/main.cpp
@@ -1150,6 +1150,9 @@ void SaveConfig() {
     // Image
     WritePrivateProfileStringW(L"Image", L"AutoRotate", g_config.AutoRotate ? L"1" : L"0", iniPath.c_str());
     WritePrivateProfileStringW(L"Image", L"ColorManagement", g_config.ColorManagement ? L"1" : L"0", iniPath.c_str());
+    WritePrivateProfileStringW(L"Image", L"EnableLosslessTransform", g_config.EnableLosslessTransform ? L"1" : L"0", iniPath.c_str());
+    WritePrivateProfileStringW(L"Image", L"EnableLossyTransform", g_config.EnableLossyTransform ? L"1" : L"0", iniPath.c_str());
+    WritePrivateProfileStringW(L"Image", L"EnableEdgeClip", g_config.EnableEdgeClip ? L"1" : L"0", iniPath.c_str());
     WritePrivateProfileStringW(L"Image", L"ForceRawDecode", g_config.ForceRawDecode ? L"1" : L"0", iniPath.c_str());
     WritePrivateProfileStringW(L"Image", L"AlwaysSaveLossless", g_config.AlwaysSaveLossless ? L"1" : L"0", iniPath.c_str());
     WritePrivateProfileStringW(L"Image", L"AlwaysSaveEdgeAdapted", g_config.AlwaysSaveEdgeAdapted ? L"1" : L"0", iniPath.c_str());
@@ -1224,6 +1227,9 @@ void LoadConfig() {
     // Image
     g_config.AutoRotate = GetPrivateProfileIntW(L"Image", L"AutoRotate", 1, iniPath.c_str()) != 0;
     g_config.ColorManagement = GetPrivateProfileIntW(L"Image", L"ColorManagement", 0, iniPath.c_str()) != 0;
+    g_config.EnableLosslessTransform = GetPrivateProfileIntW(L"Image", L"EnableLosslessTransform", 1, iniPath.c_str()) != 0;
+    g_config.EnableLossyTransform = GetPrivateProfileIntW(L"Image", L"EnableLossyTransform", 1, iniPath.c_str()) != 0;
+    g_config.EnableEdgeClip = GetPrivateProfileIntW(L"Image", L"EnableEdgeClip", 0, iniPath.c_str()) != 0;
     g_config.ForceRawDecode = GetPrivateProfileIntW(L"Image", L"ForceRawDecode", 0, iniPath.c_str()) != 0;
     g_config.AlwaysSaveLossless = GetPrivateProfileIntW(L"Image", L"AlwaysSaveLossless", 0, iniPath.c_str()) != 0;
     g_config.AlwaysSaveEdgeAdapted = GetPrivateProfileIntW(L"Image", L"AlwaysSaveEdgeAdapted", 0, iniPath.c_str()) != 0;
@@ -2193,8 +2199,32 @@ LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
         if (g_viewState.IsDragging) { 
             ReleaseCapture(); 
             g_viewState.IsDragging = false; 
+            g_viewState.IsInteracting = false;  // End interaction mode
+            // If dragging happened, don't trigger edge click or other clicks
+            InvalidateRect(hwnd, nullptr, FALSE);
+            return 0;
         }
         g_viewState.IsInteracting = false;  // End interaction mode
+
+        // Edge Navigation Click
+        if (g_config.EdgeNavClick && !g_gallery.IsVisible()) {
+            RECT rc; GetClientRect(hwnd, &rc);
+            int width = rc.right - rc.left;
+            // Left 15% -> Prev, Right 15% -> Next
+            // Exclude central area.
+            // Also ensure we didn't drag.
+            if (width > 50) { // arbitrary min width
+                if (pt.x < width * 0.15) {
+                    Navigate(hwnd, -1);
+                    return 0;
+                }
+                if (pt.x > width * 0.85) {
+                    Navigate(hwnd, 1);
+                    return 0;
+                }
+            }
+        }
+        
         InvalidateRect(hwnd, nullptr, FALSE);  // Redraw with high quality
         return 0;
     }
