#pragma once
#include "pch.h"
#include <vector>
#include <deque>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <atomic>
#include <string>
#include <mutex>
#include <thread>
#include <optional>
#include "MemoryArena.h"
#include "ImageLoader.h"
#include "ImageTypes.h"    // [Direct D2D] RawImageFrame
#include "EditState.h"
#include "SystemInfo.h"  // [N+1] Hardware detection & auto-config
#include "FileNavigator.h"  // [ImageID] For ImageID type and ComputePathHash

class HeavyLanePool; // [N+1] Forward declaration

// [N+1] Feature flag for gradual migration
// Set to 1 to use new HeavyLanePool, 0 to use old HeavyLane
// #define USE_HEAVY_POOL 1 REMOVED -> HeavyPool is now standard

// Events generated by the Engine
enum class EventType {
    None,
    PreviewReady,   // Fast Lane Result (Preview or JXL DC)
    FullReady,      // Heavy Lane Result (Final)
    LoadError,      // Something went wrong
    StatusChange,   // For UI debug/status bar "Loading...", "Idle"
    MetadataReady   // [v5.3] Async metadata update (EXIF)
};

// === Phase 3: Prefetch System ===
enum class BrowseDirection { FORWARD, BACKWARD, IDLE };
enum class Priority { Critical = 0, High = 1, Low = 2, Idle = 3 };

struct PrefetchPolicy {
    bool enablePrefetch = true;                   // Master switch [User Request: Disabled -> Enabled]
    size_t maxCacheMemory = 512 * 1024 * 1024;    // 512MB default
    int lookAheadCount = 3;                       // Forward prefetch count
};

struct CacheEntry {
    std::shared_ptr<QuickView::RawImageFrame> frame;
    int sourceIndex = -1;    // Which image index this belongs to
    size_t sizeBytes = 0;    // Memory footprint (W * H * 4)
};

struct EngineEvent {
    EventType type = EventType::None;
    std::wstring filePath; // Which file is this event for?
    uint64_t navToken = 0; // [Phase 3] Navigation session token (deprecated, use imageId)
    ImageID imageId = 0;   // [ImageID Architecture] Stable content-based hash
    
    // Payload (Optional parts)
    // CImageLoader::ThumbData thumbData;     // REMOVED (Use rawFrame + isPreview flag logic)
    ComPtr<IWICBitmapSource> fullImage;    // For FullReady (Legacy, being deprecated)
    std::shared_ptr<QuickView::RawImageFrame> rawFrame;  // [Direct D2D] New: Zero-Copy Frame
    CImageLoader::ImageMetadata metadata;  // Pre-read metadata (avoids UI blocking)
    
    // Status Message Payload
    std::wstring message;
    
    bool isScaled = false; // [Phase 11] Was image scaled during decode?
    std::wstring loaderName; // Which decoder was used
};

class ImageEngine {
public:
    ImageEngine(CImageLoader* loader);
    ~ImageEngine();

    // The Main Input: "User wants to go here"
    // fileSize: Used for Threshold Dispatch (Fast/Heavy/Express)
    /// <summary>
    /// Update Runtime Configuration (for Verification Flags)
    /// </summary>
    void UpdateConfig(const RuntimeConfig& cfg);

    /// <summary>
    /// Navigate to a new image
    /// </summary>
    // fileSize: Used for Threshold Dispatch (Fast/Heavy/Express)
    // navToken: [Phase 3] Navigation session token for event filtering
    void NavigateTo(const std::wstring& path, uintmax_t fileSize = 0, uint64_t navToken = 0);
    void SetWindow(HWND hwnd);
    
    // [v3.1] Cancel Heavy Lane when Fast Pass succeeds
    void CancelHeavy();  // Implementation in ImageEngine.cpp
    
    // [Two-Stage] Request full resolution decode for current image
    // Called after 300ms idle when viewing a scaled image
    void RequestFullDecode(const std::wstring& path, ImageID imageId);
    
    // [JXL Sequential] Trigger pending Heavy task after FastLane completes
    void TriggerPendingJxlHeavy();
    
    // [v5.3] Async Request for Auxiliary Metadata (EXIF/Stats)
    void RequestFullMetadata();

    // The Main Output: Poll this every frame (or via timer)
    // Yields events as they happen.
    // This replaces callbacks.
    // NOTE: C++23 std::generator
    // Ensure you have /std:c++latest or /std:c++20 + VS 17.9+
    // Returns a batch of events
    std::vector<EngineEvent> PollState();

    // Stats
    bool IsIdle() const;
    
    // [v4.0] Infrastructure: Global Token Access
    ImageID GetGlobalToken() const { return m_currentImageId.load(); }
    
    // [Phase 6] Dynamic Gating
    // High Priority = Warp Mode (Skip Slow Decodes)
    void SetHighPriorityMode(bool enabled);
    
    // === Phase 3: Prefetch API ===
    void SetNavigator(FileNavigator* nav) { m_navigator = nav; }
    void UpdateView(int currentIndex, BrowseDirection dir);
    void SetPrefetchPolicy(const PrefetchPolicy& policy);
    const PrefetchPolicy& GetPrefetchPolicy() const { return m_prefetchPolicy; }
    size_t GetCacheMemoryUsage() const;
    int GetCacheItemCount() const;
    std::shared_ptr<QuickView::RawImageFrame> GetCachedImage(const std::wstring& path);

    
    // === Debug/Instrumentation API ===
    enum class HeavyState { IDLE, DECODING, CANCELLING };
    enum class CacheStatus { EMPTY, FAST, HEAVY, PENDING };
    
    static constexpr int TOPOLOGY_RANGE = 2; // [-2, -1, CUR, +1, +2]
    static constexpr int HISTORY_SIZE = 60;  // 60 frames of history
    
    struct CacheTopology {
        CacheStatus slots[5]; // [-2, -1, 0, +1, +2]
    };
    
    struct ArenaStats {
        size_t activeUsed = 0;
        size_t activePeak = 0;
        size_t activeCapacity = 0;
        size_t backUsed = 0;
        size_t backPeak = 0;
        size_t backCapacity = 0;
    };
    
    // [HUD V4] Zero-Cost TelemetrySnapshot (POD)
    struct TelemetrySnapshot {
        // Zone A: Vitals
        float fps = 0.0f;
        ImageID targetHash = 0;
        ImageID renderHash = 0;
        wchar_t loaderName[64] = { 0 };
        bool syncStatus = false; // Green/Yellow/Red logic helper
        bool isScaled = false;   // [Two-Stage] True if current image is IDCT scaled
        
        // Zone A2: Legacy DComp
        bool layerImg = false;
        bool layerGal = false;
        bool layerSta = false;
        bool layerDyn = false;

        // Zone B: Matrix
        int fastQueue = 0;
        int fastDropped = 0;
        bool fastWorking = false;
        int fastDecodeTime = 0;  // [Dual Timing] Pure decode ms
        int fastTotalTime = 0;   // [Dual Timing] Total processing ms
        
        struct HeavyWorkerInfo {
            bool alive = false;
            bool busy = false; // True = Red, False = Yellow
            int lastDecodeMs = 0;  // [Dual Timing] Pure decode
            int lastTotalMs = 0;   // [Dual Timing] Total processing
            wchar_t loaderName[64] = { 0 }; // [Phase 11]
            bool isFullDecode = false;      // [Two-Stage] Match WorkerSnapshot layout
        } heavyWorkers[16]; // Fixed size for snapshot
        int heavyWorkerCount = 0;
        int heavyCancellations = 0; // [HUD V4] Total cancellations
        
        // Zone C: Logic
        static constexpr int TOPO_OFFSET = 16; // [v8.14] Centered: 16 slots each direction
        CacheStatus cacheSlots[32]; // [-16..+15] symmetric for bidirectional browsing
        int prefetchLookAhead = 0; // Active policy lookahead (0 if disabled)
        int browseDirection = 0;   // -1=Backward, 0=Idle, 1=Forward
        bool prefetchEnabled = false; // Whether prefetch is active

        
        // Zone D: Memory
        size_t pmrUsed = 0;
        size_t pmrCapacity = 0;
        size_t sysMemory = 0;    // [Phase 6] Working Set
    };
    
    TelemetrySnapshot GetTelemetry() const;
    
    // Legacy Debug API (Deprecated, to be removed)
    struct DebugStats {
        int fastQueueSize = 0;
        int fastResultsSize = 0;
        HeavyState heavyState = HeavyState::IDLE;
        size_t memoryUsed = 0;
        size_t memoryTotal = 0;
        int cancelCount = 0;       // Total Heavy cancellations (Regicide)

        int fastSkipCount = 0;    // Fast skip-middle count
        int fastDroppedCount = 0; // [HUD V4] Dropped tasks
        bool fastWorking = false; // [HUD V4] Active State
        
        double fastDecodeTimeMs = 0.0; // Last Fast Decode Time
        double fastTotalTimeMs = 0.0;  // Last Fast Total Time
        
        double heavyDecodeTimeMs = 0.0; // Last Heavy Decode Time
        ImageID fastLastImageId = 0;   // [HUD Fix] Match against current
        ImageID heavyLastImageId = 0;   // [HUD Fix] Match against current

        std::wstring loaderName;   // Last used decoder name
        int heavyPendingCount = 0; // New: Heavy Lane Pending Count
        
        // Phase 4: HUD Enhancements
        CacheTopology topology;    // Cache strip [-2..+2]
        size_t cacheMemoryUsed = 0; // Cache memory usage
        ArenaStats arena;          // Arena water levels
    };
    
    DebugStats GetDebugStats() const;
    void ResetDebugCounters();

private:
    friend class HeavyLanePool; // [N+1] Allow pool to access QueueEvent
    
    CImageLoader* m_loader;
    RuntimeConfig m_config; // Verification Flags
    TripleArenaPool m_pool; // [Unified Architecture] 3-Arena System (1 Fast + 2 Heavy)
    HWND m_hwnd = nullptr;
    std::atomic<bool> m_isHighPriority = false; // Default: Static Mode (Allow everything)

    void QueueEvent(EngineEvent&& e);
    
    // Smart skip for fast formats (PNG/GIF/BMP < 16MP)
    bool ShouldSkipFastLaneForFastFormat(const std::wstring& path);

    // [Phase 2] Dispatcher
    void DispatchImageLoad(const std::wstring& path, ImageID imageId, uintmax_t fileSize);

    // --- Lane 1: The Fast Lane ---
    class FastLane {
        friend class ImageEngine;
    public:
        FastLane(ImageEngine* parent, CImageLoader* loader);
        ~FastLane();

        // [v3.1] Ruthless Purge: Clear pending queue
        // [v3.1] Ruthless Purge: Clear pending queue
        void Clear();
        void Push(const std::wstring& path, ImageID id);
        std::optional<EngineEvent> TryPopResult();
        bool IsQueueEmpty() const;
        
        // Debug
        int GetQueueSize() const;
        int GetResultsSize() const;
        int GetSkipCount() const { return m_skipCount.load(); }
        void ResetSkipCount() { m_skipCount = 0; }
        
        // [v3.2] Fast Loader Name (for HUD)
        std::wstring GetLastLoaderName() const {
            std::lock_guard lock(m_debugMutex);
            return m_lastLoaderName;
        }
        
        std::atomic<double> m_lastDecodeTimeMs{ 0.0 }; // [Dual Timing] Pure decode
        std::atomic<double> m_lastTotalTimeMs{ 0.0 };  // [Dual Timing] Total processing
        std::atomic<ImageID> m_lastLoadId{ 0 };       // [HUD Fix] Track ImageID
        std::atomic<int> m_droppedCount{ 0 };         // [HUD V4] Dropped tasks
        std::atomic<bool> m_isWorking{ false };       // [HUD V4] Active State

    private:
        void QueueWorker(); // The Fast Lane Thread Function

        CImageLoader* m_loader;
        ImageEngine* m_parent;
        
        std::jthread m_thread; 
        mutable std::mutex m_queueMutex;
        mutable std::mutex m_debugMutex; // [v3.2] For loader name
        
        std::mutex m_pendingMutex;
        std::set<ImageID> m_pendingMetadataRequests;

        struct FastLaneCommand {
            std::wstring path;
            ImageID id;
        };
        std::deque<FastLaneCommand> m_queue; 
        std::deque<EngineEvent> m_results; 
        std::atomic<bool> m_stopSignal = false;
        std::condition_variable m_cv;
        std::atomic<int> m_skipCount = 0;
        std::wstring m_lastLoaderName; // [v3.2] Fast Loader Record
    } m_fastLane;

    // [N+1] New elastic Heavy Lane Pool
    std::unique_ptr<HeavyLanePool> m_heavyPool;
    EngineConfig m_engineConfig;

    // Tracking
    std::wstring m_currentNavPath;
    std::chrono::steady_clock::time_point m_lastInputTime;
    
    // [v3.1]
    std::atomic<bool> m_hasEmbeddedThumb = false;
    
    // [Phase 3] Navigation Token for event filtering (deprecated)
    std::atomic<uint64_t> m_currentNavToken = 0;
    
    // [ImageID Architecture] Stable content-based ID for current image
    std::atomic<ImageID> m_currentImageId{0};
    
    // [JXL Sequential] Pending Heavy task - waits for FastLane completion
    std::wstring m_pendingJxlHeavyPath;
    ImageID m_pendingJxlHeavyId = 0;

    // [Two-Stage] State Tracking
    bool m_isViewingScaledImage = false; // True if current view is Fast/Stage1 (Scaled)
    bool m_stage2Requested = false;      // True if Stage 2 (Full) has been requested
    std::chrono::steady_clock::time_point m_stage1Time; // When Stage 1 finished

    // === Phase 3: Prefetch System ===
    FileNavigator* m_navigator = nullptr;
    PrefetchPolicy m_prefetchPolicy;
    std::atomic<int> m_currentViewIndex{-1};
    std::atomic<int> m_lastDirectionInt{0}; // [v8.15] Atomic: -1=Back, 0=Idle, 1=Forward
    
    // [v8.15] Track pending images for HUD PENDING (blue) display
    std::unordered_set<std::wstring> m_pendingPaths;
    mutable std::mutex m_pendingMutex;
    
    // Global Cache (LRU)
    std::unordered_map<std::wstring, CacheEntry> m_cache;
    std::list<std::wstring> m_lruOrder; // Most recent at front
    mutable std::mutex m_cacheMutex;
    size_t m_currentCacheBytes = 0;
    
    void AddToCache(int index, const std::wstring& path, std::shared_ptr<QuickView::RawImageFrame> frame);
    void EvictCache(int currentIndex);
    void ScheduleJob(int index, Priority pri);
    void PruneQueue(int currentIndex, BrowseDirection dir);

    void CheckStartupDelay(); // [v9.0] Enable prefetch after 500ms
    std::atomic<bool> m_startupPrefetchAllowed{false}; // [v9.0] Strict Startup Delay

    // [Fix] Manual Event Queue for Cache Hits (and other internal events)
    std::vector<EngineEvent> m_manualEventQueue;
    mutable std::mutex m_manualQueueMutex;

    // [v9.1] Serial Prefetch Queue
    struct PrefetchTask {
        int index;
        Priority priority;
    };
    std::deque<PrefetchTask> m_prefetchQueue;
    void PumpPrefetch();
public:
    bool HasEmbeddedThumb() const { return m_hasEmbeddedThumb.load(); }
};
