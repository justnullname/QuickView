#pragma once
#include "pch.h"
#include <vector>
#include <deque>
#include <atomic>
#include <string>
#include <mutex>
#include <thread>
#include <optional>
#include "MemoryArena.h"
#include "ImageLoader.h"

// Events generated by the Engine
enum class EventType {
    None,
    ThumbReady,     // Scout Lane Result
    FullReady,      // Heavy Lane Result (Final)
    LoadError,      // Something went wrong
    StatusChange    // For UI debug/status bar "Loading...", "Idle"
};

struct EngineEvent {
    EventType type = EventType::None;
    std::wstring filePath; // Which file is this event for?
    
    // Payload (Optional parts)
    CImageLoader::ThumbData thumbData;     // For ThumbReady
    ComPtr<IWICBitmapSource> fullImage;    // For FullReady
    CImageLoader::ImageMetadata metadata;  // Pre-read metadata (avoids UI blocking)
    std::wstring loaderName;               // Which decoder was used
};

class ImageEngine {
public:
    ImageEngine(CImageLoader* loader);
    ~ImageEngine();

    // The Main Input: "User wants to go here"
    void NavigateTo(const std::wstring& path);

    // The Main Output: Poll this every frame (or via timer)
    // Yields events as they happen.
    // This replaces callbacks.
    // NOTE: C++23 std::generator
    // Ensure you have /std:c++latest or /std:c++20 + VS 17.9+
    // Returns a batch of events
    std::vector<EngineEvent> PollState();

    // Stats
    bool IsIdle() const;
    
    // === Debug/Instrumentation API ===
    enum class HeavyState { IDLE, DECODING, CANCELLING };
    
    struct DebugStats {
        int scoutQueueSize = 0;
        int scoutResultsSize = 0;
        HeavyState heavyState = HeavyState::IDLE;
        size_t memoryUsed = 0;
        size_t memoryTotal = 0;
        int cancelCount = 0;       // Total cancellations
        int scoutSkipCount = 0;    // Scout skip-middle count
    };
    
    DebugStats GetDebugStats() const;
    void ResetDebugCounters();

private:
    CImageLoader* m_loader;
    MemoryArena m_memory;
    
    // Smart skip for fast formats (PNG/GIF/BMP < 16MP)
    bool ShouldSkipScoutForFastFormat(const std::wstring& path);

    // --- Lane 1: The Scout ---
    class ScoutLane {
    public:
        ScoutLane(CImageLoader* loader);
        ~ScoutLane();

        void Push(const std::wstring& path);
        std::optional<EngineEvent> TryPopResult();
        bool IsQueueEmpty() const;
        
        // Debug
        int GetQueueSize() const;
        int GetResultsSize() const;
        int GetSkipCount() const { return m_skipCount.load(); }
        void ResetSkipCount() { m_skipCount = 0; }

    private:
        void QueueWorker(); // The Scout Thread Function

        CImageLoader* m_loader;
        
        std::jthread m_thread; // Auto-join on destruction
        mutable std::mutex m_queueMutex;
        std::deque<std::wstring> m_queue; // The FIFO
        std::deque<EngineEvent> m_results; // Output queue
        std::atomic<bool> m_stopSignal = false;
        std::condition_variable m_cv;
        std::atomic<int> m_skipCount = 0;  // Skip-middle counter
    } m_scout;

    // --- Lane 2: The Heavy Lifter ---
    class HeavyLane {
    public:
        HeavyLane(CImageLoader* loader, MemoryArena* memory);
        ~HeavyLane();

        void SetTarget(const std::wstring& path); // The Single Slot
        std::optional<EngineEvent> TryPopResult();
        bool IsBusy() const { return m_isBusy; }
        bool IsCancelling() const { return m_isCancelling; }
        int GetCancelCount() const { return m_cancelCount.load(); }
        void ResetCancelCount() { m_cancelCount = 0; }

    private:
        void MasterLoop(std::stop_token st); 
        // Helper to run the actual decode.
        void PerformDecode(const std::wstring& path, std::stop_token st);

        CImageLoader* m_loader;
        MemoryArena* m_memory;

        std::jthread m_thread; 
        
        std::mutex m_resultMutex;
        std::deque<EngineEvent> m_results;
        
        std::atomic<bool> m_isBusy = false;
        std::atomic<bool> m_isCancelling = false;
        std::atomic<int> m_cancelCount = 0;
        
        // --- Synchronization for Single-Slot Logic ---
        std::mutex m_jobMutex;
        std::condition_variable m_jobCv;
        std::wstring m_pendingPath;
        bool m_hasPendingJob = false;
        std::stop_source m_currentJobStopSource; // To cancel the running decode
    } m_heavy;

    // Tracking
    std::wstring m_currentNavPath;
    std::chrono::steady_clock::time_point m_lastInputTime;
};
