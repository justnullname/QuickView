#pragma once
#include "pch.h"
#include <vector>
#include <deque>
#include <list>
#include <unordered_map>
#include <atomic>
#include <string>
#include <mutex>
#include <thread>
#include <optional>
#include "MemoryArena.h"
#include "ImageLoader.h"
#include "EditState.h"
#include "SystemInfo.h"  // [N+1] Hardware detection & auto-config
#include "FileNavigator.h"  // [ImageID] For ImageID type and ComputePathHash

class HeavyLanePool; // [N+1] Forward declaration

// [N+1] Feature flag for gradual migration
// Set to 1 to use new HeavyLanePool, 0 to use old HeavyLane
// #define USE_HEAVY_POOL 1 REMOVED -> HeavyPool is now standard

// Events generated by the Engine
enum class EventType {
    None,
    ThumbReady,     // Scout Lane Result
    FullReady,      // Heavy Lane Result (Final)
    LoadError,      // Something went wrong
    StatusChange    // For UI debug/status bar "Loading...", "Idle"
};

// === Phase 3: Prefetch System ===
enum class BrowseDirection { FORWARD, BACKWARD, IDLE };
enum class Priority { Critical = 0, High = 1, Low = 2, Idle = 3 };

struct PrefetchPolicy {
    bool enablePrefetch = true;                   // Master switch
    size_t maxCacheMemory = 512 * 1024 * 1024;    // 512MB default
    int lookAheadCount = 3;                       // Forward prefetch count
};

struct CacheEntry {
    ComPtr<IWICBitmapSource> bitmap;
    int sourceIndex = -1;    // Which image index this belongs to
    size_t sizeBytes = 0;    // Memory footprint (W * H * 4)
};

struct EngineEvent {
    EventType type = EventType::None;
    std::wstring filePath; // Which file is this event for?
    uint64_t navToken = 0; // [Phase 3] Navigation session token (deprecated, use imageId)
    ImageID imageId = 0;   // [ImageID Architecture] Stable content-based hash
    
    // Payload (Optional parts)
    CImageLoader::ThumbData thumbData;     // For ThumbReady
    ComPtr<IWICBitmapSource> fullImage;    // For FullReady
    CImageLoader::ImageMetadata metadata;  // Pre-read metadata (avoids UI blocking)
    std::wstring loaderName;               // Which decoder was used
    
    // [Phase 7] Truth Stage
    bool isScaled = false; // true = Fit Stage (scaled), false = Truth Stage (full res)
};

class ImageEngine {
public:
    ImageEngine(CImageLoader* loader);
    ~ImageEngine();

    // The Main Input: "User wants to go here"
    // fileSize: Used for Threshold Dispatch (Scout/Heavy/Express)
    /// <summary>
    /// Update Runtime Configuration (for Verification Flags)
    /// </summary>
    void UpdateConfig(const RuntimeConfig& cfg);

    /// <summary>
    /// Navigate to a new image
    /// </summary>
    // fileSize: Used for Threshold Dispatch (Scout/Heavy/Express)
    // navToken: [Phase 3] Navigation session token for event filtering
    void NavigateTo(const std::wstring& path, uintmax_t fileSize = 0, uint64_t navToken = 0);
    void SetWindow(HWND hwnd);
    
    // [v3.1] Cancel Heavy Lane when Fast Pass succeeds
    void CancelHeavy();  // Implementation in ImageEngine.cpp

    // The Main Output: Poll this every frame (or via timer)
    // Yields events as they happen.
    // This replaces callbacks.
    // NOTE: C++23 std::generator
    // Ensure you have /std:c++latest or /std:c++20 + VS 17.9+
    // Returns a batch of events
    std::vector<EngineEvent> PollState();

    // Stats
    bool IsIdle() const;
    
    // [Phase 6] Dynamic Gating
    // High Priority = Warp Mode (Skip Slow Decodes)
    void SetHighPriorityMode(bool enabled);
    
    // === Phase 3: Prefetch API ===
    void SetNavigator(FileNavigator* nav) { m_navigator = nav; }
    void UpdateView(int currentIndex, BrowseDirection dir);
    void SetPrefetchPolicy(const PrefetchPolicy& policy);
    size_t GetCacheMemoryUsage() const;
    ComPtr<IWICBitmapSource> GetCachedImage(const std::wstring& path);

    
    // === Debug/Instrumentation API ===
    enum class HeavyState { IDLE, DECODING, CANCELLING };
    enum class CacheStatus { EMPTY, SCOUT, HEAVY, PENDING };
    
    static constexpr int TOPOLOGY_RANGE = 2; // [-2, -1, CUR, +1, +2]
    static constexpr int HISTORY_SIZE = 60;  // 60 frames of history
    
    struct CacheTopology {
        CacheStatus slots[5]; // [-2, -1, 0, +1, +2]
    };
    
    struct ArenaStats {
        size_t activeUsed = 0;
        size_t activePeak = 0;
        size_t activeCapacity = 0;
        size_t backUsed = 0;
        size_t backPeak = 0;
        size_t backCapacity = 0;
    };
    
    // [HUD V4] Zero-Cost TelemetrySnapshot (POD)
    struct TelemetrySnapshot {
        // Zone A: Vitals
        float fps = 0.0f;
        ImageID targetHash = 0;
        ImageID renderHash = 0;
        wchar_t loaderName[64] = { 0 };
        char imageSpecs[64] = { 0 }; // [Phase 7] Restored
        bool syncStatus = false; // Green/Yellow/Red logic helper
        
        // Zone A2: Legacy DComp
        bool layerImg = false;
        bool layerGal = false;
        bool layerSta = false;
        bool layerDyn = false;
        bool slowMo = false;

        // Zone B: Matrix
        int scoutQueue = 0;
        int scoutDropped = 0;
        bool scoutWorking = false;
        int scoutLoadTime = 0; // [Phase 9] ms
        
        struct HeavyWorkerInfo {
            bool alive = false;
            bool busy = false; // True = Red, False = Yellow
            int lastTimeMs = 0;
        } heavyWorkers[16]; // Fixed size for snapshot
        int heavyWorkerCount = 0;
        
        // Zone C: Logic
        CacheStatus cacheSlots[5]; // [-2, -1, CUR, +1, +2]
        
        // Zone D: Memory
        size_t pmrUsed = 0;
        size_t pmrCapacity = 0;
        size_t sysMemory = 0;    // [Phase 6] Working Set
    };
    
    TelemetrySnapshot GetTelemetry() const;
    
    // Legacy Debug API (Deprecated, to be removed)
    struct DebugStats {
        int scoutQueueSize = 0;
        int scoutResultsSize = 0;
        HeavyState heavyState = HeavyState::IDLE;
        size_t memoryUsed = 0;
        size_t memoryTotal = 0;
        int cancelCount = 0;       // Total Heavy cancellations (Regicide)
        int scoutSkipCount = 0;    // Scout skip-middle count
        double scoutLoadTimeMs = 0.0; // Last Scout Load Time
        double heavyDecodeTimeMs = 0.0; // Last Heavy Decode Time
        ImageID scoutLastImageId = 0;   // [HUD Fix] Match against current
        ImageID heavyLastImageId = 0;   // [HUD Fix] Match against current

        std::wstring loaderName;   // Last used decoder name
        int heavyPendingCount = 0; // New: Heavy Lane Pending Count
        
        // Phase 4: HUD Enhancements
        CacheTopology topology;    // Cache strip [-2..+2]
        size_t cacheMemoryUsed = 0; // Cache memory usage
        ArenaStats arena;          // Arena water levels
    };
    
    DebugStats GetDebugStats() const;
    void ResetDebugCounters();

private:
    friend class HeavyLanePool; // [N+1] Allow pool to access QueueEvent
    
    CImageLoader* m_loader;
    RuntimeConfig m_config; // Verification Flags
    QuantumArenaPool m_pool;
    HWND m_hwnd = nullptr;
    std::atomic<bool> m_isHighPriority = false; // Default: Static Mode (Allow everything)

    void QueueEvent(EngineEvent&& e);
    
    // Smart skip for fast formats (PNG/GIF/BMP < 16MP)
    bool ShouldSkipScoutForFastFormat(const std::wstring& path);

    // --- Lane 1: The Scout ---
    class ScoutLane {
    public:
        ScoutLane(ImageEngine* parent, CImageLoader* loader);
        ~ScoutLane();

        // [v3.1] Ruthless Purge: Clear pending queue
        void Clear();
        void Push(const std::wstring& path);
        std::optional<EngineEvent> TryPopResult();
        bool IsQueueEmpty() const;
        
        // Debug
        int GetQueueSize() const;
        int GetResultsSize() const;
        int GetSkipCount() const { return m_skipCount.load(); }
        void ResetSkipCount() { m_skipCount = 0; }
        
        // [v3.2] Scout Loader Name (for HUD)
        std::wstring GetLastLoaderName() const {
            std::lock_guard lock(m_debugMutex);
            return m_lastLoaderName;
        }
        
        std::atomic<double> m_lastLoadTimeMs{ 0.0 }; // Public atomic for easy access
        std::atomic<ImageID> m_lastLoadId{ 0 };      // [HUD Fix] Track ImageID
        std::atomic<int> m_droppedCount{ 0 };        // [HUD V4] Dropped tasks
        std::atomic<bool> m_isWorking{ false };      // [HUD V4] Active State

    private:
        void QueueWorker(); // The Scout Thread Function

        CImageLoader* m_loader;
        ImageEngine* m_parent;
        
        std::jthread m_thread; 
        mutable std::mutex m_queueMutex;
        mutable std::mutex m_debugMutex; // [v3.2] For loader name
        std::deque<std::wstring> m_queue; 
        std::deque<EngineEvent> m_results; 
        std::atomic<bool> m_stopSignal = false;
        std::condition_variable m_cv;
        std::atomic<int> m_skipCount = 0;
        std::wstring m_lastLoaderName; // [v3.2] Scout Loader Record
    } m_scout;

    // [N+1] New elastic Heavy Lane Pool
    std::unique_ptr<HeavyLanePool> m_heavyPool;
    EngineConfig m_engineConfig;

    // Tracking
    std::wstring m_currentNavPath;
    std::chrono::steady_clock::time_point m_lastInputTime;
    
    // [v3.1]
    std::atomic<bool> m_hasEmbeddedThumb = false;
    
    // [Phase 3] Navigation Token for event filtering (deprecated)
    std::atomic<uint64_t> m_currentNavToken = 0;
    
    // [ImageID Architecture] Stable content-based ID for current image
    std::atomic<ImageID> m_currentImageId{0};

    // === Phase 3: Prefetch System ===
    FileNavigator* m_navigator = nullptr;
    PrefetchPolicy m_prefetchPolicy;
    int m_currentViewIndex = -1;
    BrowseDirection m_lastDirection = BrowseDirection::IDLE;
    
    // Global Cache (LRU)
    std::unordered_map<std::wstring, CacheEntry> m_cache;
    std::list<std::wstring> m_lruOrder; // Most recent at front
    mutable std::mutex m_cacheMutex;
    size_t m_currentCacheBytes = 0;
    
    void AddToCache(int index, const std::wstring& path, IWICBitmapSource* bitmap);
    void EvictCache(int currentIndex);
    void ScheduleJob(int index, Priority pri);
    void PruneQueue(int currentIndex, BrowseDirection dir);


public:
    bool HasEmbeddedThumb() const { return m_hasEmbeddedThumb.load(); }
};
