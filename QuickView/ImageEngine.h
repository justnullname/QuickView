#pragma once
#include "pch.h"
#include <vector>
#include <deque>
#include <list>
#include <unordered_map>
#include <atomic>
#include <string>
#include <mutex>
#include <thread>
#include <optional>
#include "MemoryArena.h"
#include "ImageLoader.h"
#include "EditState.h"

class FileNavigator; // Forward declaration

// Events generated by the Engine
enum class EventType {
    None,
    ThumbReady,     // Scout Lane Result
    FullReady,      // Heavy Lane Result (Final)
    LoadError,      // Something went wrong
    StatusChange    // For UI debug/status bar "Loading...", "Idle"
};

// === Phase 3: Prefetch System ===
enum class BrowseDirection { FORWARD, BACKWARD, IDLE };
enum class Priority { Critical = 0, High = 1, Low = 2, Idle = 3 };

struct PrefetchPolicy {
    bool enablePrefetch = true;                   // Master switch
    size_t maxCacheMemory = 512 * 1024 * 1024;    // 512MB default
    int lookAheadCount = 3;                       // Forward prefetch count
};

struct CacheEntry {
    ComPtr<IWICBitmapSource> bitmap;
    int sourceIndex = -1;    // Which image index this belongs to
    size_t sizeBytes = 0;    // Memory footprint (W * H * 4)
};

struct EngineEvent {
    EventType type = EventType::None;
    std::wstring filePath; // Which file is this event for?
    
    // Payload (Optional parts)
    CImageLoader::ThumbData thumbData;     // For ThumbReady
    ComPtr<IWICBitmapSource> fullImage;    // For FullReady
    CImageLoader::ImageMetadata metadata;  // Pre-read metadata (avoids UI blocking)
    std::wstring loaderName;               // Which decoder was used
    
    // [Phase 7] Truth Stage
    bool isScaled = false; // true = Fit Stage (scaled), false = Truth Stage (full res)
};

class ImageEngine {
public:
    ImageEngine(CImageLoader* loader);
    ~ImageEngine();

    // The Main Input: "User wants to go here"
    // fileSize: Used for Threshold Dispatch (Scout/Heavy/Express)
    /// <summary>
    /// Update Runtime Configuration (for Verification Flags)
    /// </summary>
    void UpdateConfig(const RuntimeConfig& cfg);

    /// <summary>
    /// Navigate to a new image
    /// </summary>
    // fileSize: Used for Threshold Dispatch (Scout/Heavy/Express)
    void NavigateTo(const std::wstring& path, uintmax_t fileSize = 0);
    void SetWindow(HWND hwnd);
    
    // [v3.1] Cancel Heavy Lane when Fast Pass succeeds
    void CancelHeavy() { m_heavy.SetTarget(L""); }

    // The Main Output: Poll this every frame (or via timer)
    // Yields events as they happen.
    // This replaces callbacks.
    // NOTE: C++23 std::generator
    // Ensure you have /std:c++latest or /std:c++20 + VS 17.9+
    // Returns a batch of events
    std::vector<EngineEvent> PollState();

    // Stats
    bool IsIdle() const;
    
    // [Phase 6] Dynamic Gating
    // High Priority = Warp Mode (Skip Slow Decodes)
    void SetHighPriorityMode(bool enabled);
    
    // === Phase 3: Prefetch API ===
    void SetNavigator(FileNavigator* nav) { m_navigator = nav; }
    void UpdateView(int currentIndex, BrowseDirection dir);
    void SetPrefetchPolicy(const PrefetchPolicy& policy);
    size_t GetCacheMemoryUsage() const;
    ComPtr<IWICBitmapSource> GetCachedImage(const std::wstring& path);

    
    // === Debug/Instrumentation API ===
    enum class HeavyState { IDLE, DECODING, CANCELLING };
    
    struct DebugStats {
        int scoutQueueSize = 0;
        int scoutResultsSize = 0;
        HeavyState heavyState = HeavyState::IDLE;
        size_t memoryUsed = 0;
        size_t memoryTotal = 0;
        int cancelCount = 0;       // Total Heavy cancellations (Regicide)
        int scoutSkipCount = 0;    // Scout skip-middle count
        double scoutLoadTimeMs = 0.0; // Last Scout Load Time
        double heavyDecodeTimeMs = 0.0; // Last Heavy Decode Time

        std::wstring loaderName;   // Last used decoder name
        int heavyPendingCount = 0; // New: Heavy Lane Pending Count
    };
    
    DebugStats GetDebugStats() const;
    void ResetDebugCounters();

private:
    CImageLoader* m_loader;
    RuntimeConfig m_config; // Verification Flags
    QuantumArenaPool m_pool;
    HWND m_hwnd = nullptr;
    std::atomic<bool> m_isHighPriority = false; // Default: Static Mode (Allow everything)

    void QueueEvent(EngineEvent&& e);
    
    // Smart skip for fast formats (PNG/GIF/BMP < 16MP)
    bool ShouldSkipScoutForFastFormat(const std::wstring& path);

    // --- Lane 1: The Scout ---
    class ScoutLane {
    public:
        ScoutLane(ImageEngine* parent, CImageLoader* loader);
        ~ScoutLane();

        void Push(const std::wstring& path);
        std::optional<EngineEvent> TryPopResult();
        bool IsQueueEmpty() const;
        
        // Debug
        int GetQueueSize() const;
        int GetResultsSize() const;
        int GetSkipCount() const { return m_skipCount.load(); }
        void ResetSkipCount() { m_skipCount = 0; }
        
        // [v3.2] Scout Loader Name (for HUD)
        std::wstring GetLastLoaderName() const {
            std::lock_guard lock(m_debugMutex);
            return m_lastLoaderName;
        }
        
        std::atomic<double> m_lastLoadTimeMs{ 0.0 }; // Public atomic for easy access

    private:
        void QueueWorker(); // The Scout Thread Function

        CImageLoader* m_loader;
        ImageEngine* m_parent;
        
        std::jthread m_thread; 
        mutable std::mutex m_queueMutex;
        mutable std::mutex m_debugMutex; // [v3.2] For loader name
        std::deque<std::wstring> m_queue; 
        std::deque<EngineEvent> m_results; 
        std::atomic<bool> m_stopSignal = false;
        std::condition_variable m_cv;
        std::atomic<int> m_skipCount = 0;
        std::wstring m_lastLoaderName; // [v3.2] Scout Loader Record
    } m_scout;

    // --- Lane 2: The Heavy Lifter ---
    class HeavyLane {
    public:
        HeavyLane(ImageEngine* parent, CImageLoader* loader, QuantumArenaPool* pool);
        ~HeavyLane();

        void SetTarget(const std::wstring& path); // The Single Slot
        std::optional<EngineEvent> TryPopResult();
        bool IsBusy() const { return m_isBusy; }
        bool IsCancelling() const { return m_isCancelling; }
        int GetCancelCount() const { return m_cancelCount.load(); }
        void ResetCancelCount() { m_cancelCount = 0; }
        
        HeavyState GetState() const {
            if (m_isCancelling) return HeavyState::CANCELLING;
            if (m_isBusy) return HeavyState::DECODING;
            return HeavyState::IDLE;
        }

        // Debug Access (Called by parent)
        double GetLastDecodeTime() const { return m_lastDecodeTimeMs.load(); }
        std::wstring GetLastLoaderName() const { 
            std::lock_guard lock(m_debugMutex);
            return m_lastLoaderName; 
        }
        
        int GetPendingCount() {
            std::lock_guard lock(m_jobMutex);
            return m_hasPendingJob ? 1 : 0;
        }
        
    private:
        void MasterLoop(std::stop_token st); 
        // Helper to run the actual decode.
        void PerformDecode(const std::wstring& path, std::stop_token st);

        ImageEngine* m_parent;
        CImageLoader* m_loader;
        QuantumArenaPool* m_pool; // Shared Pool (Thread-safe usage logic required)

        std::jthread m_thread; 
        
        std::mutex m_resultMutex;
        std::deque<EngineEvent> m_results;
        
        std::atomic<bool> m_isBusy = false;
        std::atomic<bool> m_isCancelling = false;
        std::atomic<int> m_cancelCount = 0;
        
        // --- Synchronization for Single-Slot Logic ---
        std::mutex m_jobMutex;
        std::condition_variable m_jobCv;
        std::wstring m_pendingPath;
        bool m_hasPendingJob = false;
        std::stop_source m_currentJobStopSource; // To cancel the running decode
        
        // Debug
        std::atomic<double> m_lastDecodeTimeMs = 0.0;
        std::wstring m_lastLoaderName;

        mutable std::mutex m_debugMutex; // Protect string access
        
    } m_heavy;

    // Tracking
    std::wstring m_currentNavPath;
    std::chrono::steady_clock::time_point m_lastInputTime;
    
    // [v3.1]
    std::atomic<bool> m_hasEmbeddedThumb = false;

    // === Phase 3: Prefetch System ===
    FileNavigator* m_navigator = nullptr;
    PrefetchPolicy m_prefetchPolicy;
    int m_currentViewIndex = -1;
    BrowseDirection m_lastDirection = BrowseDirection::IDLE;
    
    // Global Cache (LRU)
    std::unordered_map<std::wstring, CacheEntry> m_cache;
    std::list<std::wstring> m_lruOrder; // Most recent at front
    mutable std::mutex m_cacheMutex;
    size_t m_currentCacheBytes = 0;
    
    void AddToCache(int index, const std::wstring& path, IWICBitmapSource* bitmap);
    void EvictCache(int currentIndex);
    void ScheduleJob(int index, Priority pri);
    void PruneQueue(int currentIndex, BrowseDirection dir);


public:
    bool HasEmbeddedThumb() const { return m_hasEmbeddedThumb.load(); }
};
